NIP-68
======

Debit Requests
--------------

`wip` `rfc` `optional`

This NIP defines a method for applications to request Lightning payments be made by a users remote wallet with event kind `21002`. This complements [NIP-69](69.md) by allowing the inverse operation, and providing users with a static endpoint that applications and services can use for a more fluid and secure authorization UX than is currently available with LNURL or NWC. 

## Motivation

The UX of NWC is extremely limited in its forcing the user to pre-provision keys and define rules for each connection, then insecurely fumble those keys over to each service. NWC is also unscalable from the services perspective, as it has to fire up a new client for each connection no terms are co-established, limiting utility in common scenarios like recurring payments. NWC also fails to leverage the benefits of Nostr as a reputation system, including the ability to establish spending rules based on an endless variety of graph data. 

The ideal UX target with with NIP-68 (and 69) is:  A user enters a NIP-05 or Lightning Address into a service and then accepts a request notification in their wallet that establishes the connection with clear terms.

## Specification

### Debit Request Pointers 

A debit request pointer is a bech32 (per [NIP-19](19.md)) encoded string prefixed with `ndebit`. 
The encoded string will include the following TLV (Type-Length-Value) items:

- `0`: The 32 bytes of the wallet service's public key, encoded in hex.
- `1`: The relay URL where the wallet service subscribes to payment requests.
- `2`: Pointer Identifier.

If the pointer ID is not declared, the requestor may assume that the listening key is acting as the identifier and omit the ID field from their request.

Example pointer structure:

```
ndebit1...
  0: <wallet_service_pubkey_hex>
  1: <relay_url>
  2: <pointer_id> 
```

## Integration with other NIPs

### NIP-01 User Metadata

Users might advertise this capability so that all of their apps have the pay source awareness. 

Example user metadata content with `nip68` field:
```json
{
  "pubkey": "hex_pub",
  "kind": 0,
  "content": "{\"name\": \"bob\", \"nip05\": \"bob@example.com\", \"nip68\": \"ndebit1...\"}"
  // ...
}
```

### NIP-05 "Lightning Addresses"

To make connecting an app to your wallet as simple as pasting your Lightning Address, name services can add a `nip68` field in the NIP-05 content for pointer discovery on name-based lookups.

Example NIP-05 Service Response with Debit Request Pointers


```json
{
  "names": {
    "bob": "hex_pub"
  },
  "nip68": {
    "bob": "ndebit1..."
  }
}
```

## Nostr Events

This NIP specifies use of event kind `21002` with the following structure: 

- `content`: NIP-44 encrypted request details.
- `tags`: 
  - `p`: Receiver's public key (hex).
  - `e`: Used in response to the requesting event.

Example request event:

```json
{
  "id": "<event_id>",
  "pubkey": "<application_pubkey>",
  "created_at": 1234567890,
  "kind": 21002,
  "tags": [
    ["p", "<wallet_pubkey>"]
  ],
  "content": "<NIP-44 encrypted request>",
  "sig": "<signature>"
}
```

The `content` field after NIP-44 decryption must contain one of the following structures:

1. For a payment request:

```json
{
    "pointer": "<pointer_id>", // optionally undefined
    "amount_sats": 1000000,
    "bolt11": "<BOLT11_invoice_string>",
    "description": "<optional_app_data>"
}
```

2. For a budget request:

```json
{
    "pointer": "<pointer_id>", // optionally undefined
    "amount_sats": 1000000,
    "frequency": {
        "number": 1,
        "unit": "month" // Possible values: "day", "week", "month"
    },
    "description": "<optional_app_data>"
}
```

The wallet service MAY require `amount_sats` in order to process rules without first decoding the invoice, but then MUST ensure the invoice amount matches before completing the request.

For budget requests, the absence of the `frequency` field indicates a one-time budget without rollover.

### Response events

Wallet services should respond with the preimage when a direct payment request is fulfilled, or simply "ok" when a budget request is approved.

The wallet service MAY respond with a **GFY** (General Failure to Yield) code when a request will not be fulfilled.

1. ACK with Lightning preimage (for direct payment):

```json
{
  "id": "<response_event_id>",
  "pubkey": "<wallet_pubkey>",
  "created_at": 1234567891,
  "kind": 21002,
  "tags": [
    ["p", "<application_pubkey>"],
    ["e", "<event_id>"] // original request event ID
  ],
  "content": "<NIP-44 encrypted {\"res\":\"ok\",\"preimage\":\"<lightning_preimage>\"}>",
  "sig": "<signature>"
}
```

1b. ACK a budget request:

```json
{
  "id": "<response_event_id>",
  "pubkey": "<wallet_pubkey>",
  "created_at": 1234567891,
  "kind": 21002,
  "tags": [
    ["p", "<application_pubkey>"],
    ["e", "<event_id>"] // original request event ID
  ],
  "content": "<NIP-44 encrypted {\"res\":\"ok\"}>",
  "sig": "<signature>"
}
```

2. GFY response:

```json
{ // ...
  "content": "<NIP-44 encrypted {\"res\":\"GFY\",\"code\":2,\"error\":\"Unknown Lightning Failure\"}>",
  "sig": "<signature>"
}
```

## GFY Handling

To facilitate consistent handling across implementations, this NIP defines the following GFY responses:

1. **Request Denied Warning**: When the request is denied by the wallet service. This serves as a warning to the requestor they may be reported on subsequent attempts.
2. **Temporary Failure**: When the wallet service is temporarily unable to process the request. This can include:
3. **Expired Request**: When the delta between the request and wallet time (unix) is too great (Default 30s).
4. **Rate Limited**: The requestor has been rate-limited by the wallet.
5. **Invalid Amount**: When the amount specified is too big or too small, providing the acceptable range.
6. **Invalid Request**: When the request is in some way malformed. 

### GFY Codes

- 1: Request Denied Warning
- 2: Temporary Failure
- 3: Expired Request
- 4: Rate Limited
- 5: Invalid Amount
- 6: Invalid Request

Clients MUST handle these responses gracefully and display appropriate messages to users.

### GFY Response Payloads

GFY responses must be sent as kind `21002` events with the following structure in the encrypted content:

```json
{
  "res": "GFY",
  "code": <gfy_code>,
  "error": "<gfy_message>",
  // Additional fields optionally included depending on the error type
}
```

### Expected Payloads

1. **Request Denied Warning**
   - **Code**: 1
   - **Payload**:
     ```json
     {
       "res": "GFY",
       "code": 1,
       "error": "Request Denied"
     }
     ```

2. **Temporary Failure**
   - **Code**: 2
   - **Payload**:
     ```json
     {
       "res": "GFY",
       "code": 2,
       "error": " ... Failure"
     }
     ```

3. **Expired Request**
   - **Code**: 3
   - **Payload**:
     ```json
     {
       "res": "GFY",
       "code": 3,
       "error": "Expired Request",
       "delta": {
         "max_delta_ms": 30000,
         "actual_delta_ms": 45000
       }
     }
     ```

4. **Rate Limited**
   - **Code**: 4
   - **Payload**:
     ```json
     {
       "res": "GFY",
       "code": 4,
       "error": "Rate Limited",
       "retry_after": 1672531199
     }
     ```

5. **Invalid Amount**
   - **Code**: 5
   - **Payload**:
     ```json
     {
       "res": "GFY",
       "code": 5,
       "error": "Invalid Amount",
       "range": {
         "min": 10,
         "max": 1000000
       }
     }
     ```

6. **Invalid Request**
   - **Code**: 6
   - **Payload**:
     ```json
     {
       "res": "GFY",
       "code": 6,
       "error": "Invalid Request"
     }
     ```

Applications MUST handle these error responses gracefully and display appropriate messages to users.

## Process Flow

1. User provides their pointer via direct paste or NIP-05 to an application.
2. Application parses the debit pointer for the public key of the listener (user's wallet service), the relay on which it's listening, and an identifying value.
3. Application sends a debit request event (kind 2102) to the specified relay, either for a direct payment or a budget request.
4. User's wallet service receives the request and either:
   a) Prompts the user to approve/deny the payment or budget, or
   b) Automatically approves/denies based on predefined rules.
5. If approved:
   - For direct payments: the wallet service processes the payment and adds the preimage details in the encrypted content of an ACK response.
   - For budget requests: the wallet service approves the budget and sends an "ok" response.
6. Wallet service sends a response event (kind 2102) with an `e` tag referencing the original request.

* If the request is denied at step 4 the service may, at it's discretion, respond with a GFY code. 

## Wallet Service Behavior

Wallet services should implement the following:

1. Listen for kind 2102 events on specified relays.
2. Implement user-defined rules for automatic approval/denial based on requesting application's pubkey, amount, frequency (for budgets), and other factors.
3. Prompt the user for manual approval when necessary, distinguishing between direct payments and budget requests.
4. Send kind 2102 response events.
5. Process payments for approved direct payment requests and provide for user management for budgets.
## Wallet Client Behavior

Wallet clients should implement the following:

1. Notifications and inboxes for pending requests, clearly distinguishing between direct payments and budget requests.
2. An address book of whitelisted / blacklisted keys.
3. Reporting functionality (ex: NIP-56)
4. Completed request payments in transaction history.
5. Source verification: Allow user to inspect the signature of the event and/or provide context known about the requesting key. 

## Application Behavior

Applications should:

1. Obtain the user's NIP-68 debit link.
2. Send kind 2102 events to request payments or budgets.
3. Listen for kind 2102 response events.
4. Handle approvals and denials appropriately.
5. Source verification: Provide astute users with the requesting key and signature they can use to verify authenticity of the request.

## Security Considerations

1. All content fields must be encrypted using [NIP-44](44.md).
2. Wallet services should implement strong authentication and atomic transactions to ensure that only authorized applications are granted debits and are properly constrained by user-defined budgets.
3. Users should be educated about the implications of setting auto-approval rules.
4. Wallet services should consider implementing "fail2ban" schemes and NIP-56 reporting to discourage abuse.

## Handling Fluctuating Amounts and Exchange Rates

When dealing with payments or budgets that are pegged to fiat currencies or other transient assets, it's important to consider how to handle fluctuations in the Bitcoin exchange rate. This NIP recommends the following approaches:

### Client-side Handling

1. Wallet clients SHOULD allow users to set rules based on both satoshi amounts and fiat currency amounts.

2. When creating a rule based on a fiat currency amount, the wallet client SHOULD:
   - Log the current exchange rate based on the users quoting preferences
   - Periodically check for changes in the exchange rate
   - Prompt the user to update their rules if the exchange rate has changed within a certian threshold

3. Wallet clients MAY implement automatic adjustments to satoshi amounts based on exchange rate fluctuations, but this MUST be clearly communicated to and approved by the user.

### Service-side Handling

1. Services MAY send new budget requests to update pricing when there are significant changes in the exchange rate.

2. When sending an updated budget request, services MUST use the same `pointer` value as the original request to associate it with the existing budget.

3. Wallet services SHOULD treat updated budget requests as new requests requiring user approval, even if the original budget was set to auto-approve.

### Example Updated Budget Request

```json
{
    "pointer": "<original_pointer_id>",
    "amount_sats": 1050000, // Updated amount
    "frequency": {
        "number": 1,
        "unit": "month"
    },
    "description": "Updated pricing due to exchange rate change. Previous: $50 (1000000 sats), New: $50 (1050000 sats)" // optional
}
```

By following these recommendations, both wallet clients and services can gracefully handle scenarios where payment amounts may fluctuate due to exchange rate changes, while maintaining transparency and control for the user.

## Reference Implementation

Lightning.Pub / ShockWallet nip68 branches